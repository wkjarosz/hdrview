//
// Copyright (C) Wojciech Jarosz <wjarosz@gmail.com>. All rights reserved.
// Use of this source code is governed by a BSD-style license that can
// be found in the LICENSE.txt file.
//

#include "common.h"
#include <regex>

using namespace std;

// These variables are autogenerated and compiled
// into the project by the version.cmake script
extern const char *GIT_TAG;
extern const char *GIT_REV;
extern const char *GIT_BRANCH;
extern const char *HDRVIEW_BUILD_TIME;

const char *hdrview_git_version() { return GIT_TAG; }
const char *hdrview_git_revision() { return GIT_REV; }
const char *hdrview_git_branch() { return GIT_BRANCH; }
const char *hdrview_timestamp() { return HDRVIEW_BUILD_TIME; }

string get_extension(const string &filename)
{
    if (filename.find_last_of(".") != string::npos)
        return filename.substr(filename.find_last_of(".") + 1);
    return "";
}

string get_basename(const string &filename)
{
    auto lastSlash = filename.find_last_of("/\\");
    auto lastDot   = filename.find_last_of(".");
    if (lastSlash == std::string::npos && lastDot == std::string::npos)
        return filename;

    auto start  = (lastSlash != string::npos) ? lastSlash + 1 : 0;
    auto length = (lastDot != string::npos) ? lastDot - start : filename.size() - start;
    return filename.substr(start, length);
}

const vector<string> &channel_names()
{
    static const vector<string> names = {"RGB",         "Red",
                                         "Green",       "Blue",
                                         "Alpha",       "Luminance",
                                         "CIE L*",      "CIE a*",
                                         "CIE b*",      "CIE chromaticity",
                                         "False color", "Negative-positive"};
    return names;
}

const vector<string> &blend_mode_names()
{
    static const vector<string> names = {
        "Normal", "Multiply", "Divide", "Add", "Average", "Subtract", "Difference", "Relative difference",
    };
    return names;
}

string channel_to_string(EChannel channel) { return channel_names()[channel]; }

string blend_mode_to_string(EBlendMode mode) { return blend_mode_names()[mode]; }

// The following functions are adapted from tev:
// This file was developed by Thomas MÃ¼ller <thomas94@gmx.net>.
// It is published under the BSD 3-Clause License within the LICENSE file.

vector<string> split(string text, const string &delim)
{
    vector<string> result;
    while (true)
    {
        size_t begin = text.find_last_of(delim);
        if (begin == string::npos)
        {
            result.emplace_back(text);
            return result;
        }
        else
        {
            result.emplace_back(text.substr(begin + 1));
            text.resize(begin);
        }
    }

    return result;
}

string to_lower(string str)
{
    transform(begin(str), end(str), begin(str), [](unsigned char c) { return (char)tolower(c); });
    return str;
}

string to_upper(string str)
{
    transform(begin(str), end(str), begin(str), [](unsigned char c) { return (char)toupper(c); });
    return str;
}

bool matches(string text, string filter, bool isRegex)
{
    auto matchesFuzzy = [](string text, string filter)
    {
        if (filter.empty())
            return true;

        // Perform matching on lowercase strings
        text   = to_lower(text);
        filter = to_lower(filter);

        auto words = split(filter, ", ");
        // We don't want people entering multiple spaces in a row to match everything.
        words.erase(remove(begin(words), end(words), ""), end(words));

        if (words.empty())
            return true;

        // Match every word of the filter separately.
        for (const auto &word : words)
            if (text.find(word) != string::npos)
                return true;

        return false;
    };

    auto matchesRegex = [](string text, string filter)
    {
        if (filter.empty())
            return true;

        try
        {
            regex searchRegex{filter, std::regex_constants::ECMAScript | std::regex_constants::icase};
            return regex_search(text, searchRegex);
        }
        catch (const regex_error &)
        {
            return false;
        }
    };

    return isRegex ? matchesRegex(text, filter) : matchesFuzzy(text, filter);
}