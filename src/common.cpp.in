//
// Copyright (C) Wojciech Jarosz <wjarosz@gmail.com>. All rights reserved.
// Use of this source code is governed by a BSD-style license that can
// be found in the LICENSE.txt file.
//

#include "common.h"
#include "json.h"
#include <regex>
#include <sago/platform_folders.h>
#include <filesystem/path.h>
#include <fstream>

using namespace std;

string config_directory() { return sago::getConfigHome() + "/HDRView/"; }

// These constants and strings are autogenerated and compiled
// into the project by cmake
int hdrview_version_major()      { return @VERSION_MAJOR@;            }
int hdrview_version_minor()      { return @VERSION_MINOR@;            }
int hdrview_version_patch()      { return @VERSION_PATCH@;            }
string hdrview_version()         { return string("@HDRVIEW_VERSION@");}
string hdrview_git_hash()        { return string("@GIT_HASH@");       }
string hdrview_git_describe()    { return string("@GIT_DESCRIBE@");   }
string hdrview_build_timestamp() { return string("@BUILD_TIME@");     }

string get_extension(const string &filename)
{
    if (filename.find_last_of(".") != string::npos)
        return filename.substr(filename.find_last_of(".") + 1);
    return "";
}

string get_basename(const string &filename)
{
    auto lastSlash = filename.find_last_of("/\\");
    auto lastDot   = filename.find_last_of(".");
    if (lastSlash == std::string::npos && lastDot == std::string::npos)
        return filename;

    auto start  = (lastSlash != string::npos) ? lastSlash + 1 : 0;
    auto length = (lastDot != string::npos) ? lastDot - start : filename.size() - start;
    return filename.substr(start, length);
}

const vector<string> &channel_names()
{
    static const vector<string> names{"RGB",
                                      "Red",
                                      "Green",
                                      "Blue",
                                      "Alpha",
                                      "Luminance",
                                      "Gray",
                                      "CIE L*",
                                      "CIE a*",
                                      "CIE b*",
                                      "CIE chromaticity",
                                      "False color",
                                      "Negative-positive"};
    return names;
}

const vector<string> &blend_mode_names()
{
    static const vector<string> names{
        "Normal", "Multiply", "Divide", "Add", "Average", "Subtract", "Difference", "Relative difference",
    };
    return names;
}

string channel_to_string(EChannel channel) { return channel_names()[channel]; }

string blend_mode_to_string(EBlendMode mode) { return blend_mode_names()[mode]; }

// The following functions are adapted from tev:
// This file was developed by Thomas MÃ¼ller <thomas94@gmx.net>.
// It is published under the BSD 3-Clause License within the LICENSE file.

vector<string> split(string text, const string &delim)
{
    vector<string> result;
    while (true)
    {
        size_t begin = text.find_last_of(delim);
        if (begin == string::npos)
        {
            result.emplace_back(text);
            return result;
        }
        else
        {
            result.emplace_back(text.substr(begin + 1));
            text.resize(begin);
        }
    }

    return result;
}

string to_lower(string str)
{
    transform(begin(str), end(str), begin(str), [](unsigned char c) { return (char)tolower(c); });
    return str;
}

string to_upper(string str)
{
    transform(begin(str), end(str), begin(str), [](unsigned char c) { return (char)toupper(c); });
    return str;
}

bool matches(string text, string filter, bool is_regex)
{
    auto matchesFuzzy = [](string text, string filter)
    {
        if (filter.empty())
            return true;

        // Perform matching on lowercase strings
        text   = to_lower(text);
        filter = to_lower(filter);

        auto words = split(filter, ", ");
        // We don't want people entering multiple spaces in a row to match everything.
        words.erase(remove(begin(words), end(words), ""), end(words));

        if (words.empty())
            return true;

        // Match every word of the filter separately.
        for (const auto &word : words)
            if (text.find(word) != string::npos)
                return true;

        return false;
    };

    auto matchesRegex = [](string text, string filter)
    {
        if (filter.empty())
            return true;

        try
        {
            regex searchRegex{filter, std::regex_constants::ECMAScript | std::regex_constants::icase};
            return regex_search(text, searchRegex);
        }
        catch (const regex_error &)
        {
            return false;
        }
    };

    return is_regex ? matchesRegex(text, filter) : matchesFuzzy(text, filter);
}



json read_settings()
{
    try
    {
        string directory = config_directory();
        ::filesystem::create_directories(directory);
        string filename = directory + "settings.json";
        spdlog::info("Reading configuration from file {}", filename);

        std::ifstream stream(filename);
        if (!stream.good())
            throw std::runtime_error(fmt::format("Cannot open settings file: \"{}\".", filename));

        json settings;
        stream >> settings;
        return settings;
    }
    catch (const exception &e)
    {
        spdlog::warn("Could not read settings file: {}", e.what());
        spdlog::info("Using default settings.");
        return json::object();
    }
}